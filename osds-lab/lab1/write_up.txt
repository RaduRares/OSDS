

.bss -> variabile globale neinitializate
.data -> variabile globale initializate
.rodata -> date read-only ca sting uri si constante
.text -> instructiuni de se executa

->stack ul este la final deoarece creste in jos,
adica pointeaza la adrese mai mici si pentru a avea 
coliziune cu heap ul 

-> 
1.

folosesc vmmap 
si p &var adresa

p &useful (pt a vedea adresa variabilei )

disassemble function pentru a vedea cod asm


2. Pt a vedea file offset ma uit cu -> objdump -d binary exec_name -F sau cu disassemble functie din gdb

   long offset = 0x1106; // pt ca e no-pie orice program incepe de la 4000 si am scazut adresa functiei - 0x4000 
 
 0x40114f - 0x401106 =  0x49 + 1 

Dupa mmap are o pagina in plus     0x7ffff7fbe000     0x7ffff7fbf000 rwxp     1000      0 [anon_7ffff7fbe] care are toate drepturile si este o sectiune separata

3.
in functia print_msg pune primul argument rdi dar e de tip int si pune in  edi de tip DWORD (32 biti adica 4 octeti ) si al doilea in rsi

Am pus in primul argument din functia print_msg variabila print iar ca instruction point (rip) am pus ineputul functiei
Va da sigsegv pentru ca nu are adresa de return pe stiva  set $rdi= message set $rip =  0x401156



*RSP  0x7fffffffdc08 ◂— 0x300000000
*RIP  0x1b00000000
─────────────────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────────────────────────────────────────────────────────────────────────────
Invalid address 0x1b00000000

PLUS:
1. in /proc/self/ apare si environ, care afiseaza envuri , daca aplicatia web le hosteaza apar aici 
2.